# Bitcoin
Bitcoins take in a message and a hash function is applied to it, in this case we use the SHA 256 hash. This process is done in order to maintain the security of the bitcoin as the hashed string cannot be reversed. We input a random string and find hash values for that string and the leading numbers of zeros in the value that we obtained must match the input zero values that we provide. If there is a match among them, then the bitcoin is found.

We need to apply the actor model and use Erlang to obtain a solution for this problem. Actor model makes it more flexible to obtain multiple hashed strings. We must also test if this runs on multi core systems.

- Requirements:
Input: The input that we give must be the number of zero's that we want

- Expected Output: The output is only valid if the number of leading zero's is equal to the input zero's that we provided. The input string that we provided, the hashed string that we got after applying the SHA 256 function. They must be separarted by a tab for each bitcoins that we find. The input string must have the gator id of one of the team members 


## Group Members
1)  Saikumar Padamati , UFID: 20721705, padamatisaikumar@ufl.edu  
2)  Aalekya Reddy Chintala, UFID: 61983722, achintala@ufl.edu

## Project Description

The details of the project are mentioned below.

### File Descriptions
1) Program.fs: This is the main file that would toggle to either the server or the client based on the input provided by the user. If the input is an integer, server is initialized with the integer as leading number of zeros, else the IP address is considered to be the server IP address and the client is initialized.
2) Server.fsx: This file represents the server.
3) Client.fsx: This file represents the client.
4) MessageTypes.fsx: This file defines message types for both client and server.
5) Utility.fs: This file consists of all common functionality used by multiple actors generated by server or client.

### Instructions to run
This project has been developed using Visual Studio Code and ionide extension. 

Please make sure you have Dotnet SDK installed on your system.
In Visual Studio, go to Market Place Extension and search, select and install: "ionide-fsharp".

1) To initialize the server, execute: dotnet run leadingZeroValue (example: dotnet run 4). Make sure to update the IP address in the config file to either localhost or your local LAN address.
2) To initialize the client, execute the following command : dotnet run "server_ip_address:port" (example: dotnet run "192.168.1.5:6969"). Make sure to update the IP address in the config file to either localhost or your local LAN address.

### Implementation Details
1) Program.fs: This file simply initializes the server or the client based on the user input.
2) Server.fsx: This file takes in the leading zeros as the input. We have a character set of [a..z A..Z 0..9] (total 62 characters). The server generates (processorCount - 1) actors to calculate hashes for given character count value as input. It also generates a parent actor which essentially acts as a supervisor for the server. We iterate over every single character count and allocate a single character count to an actor. Each actor tries (62 ^ characterCount) combinations of strings for the given input. If they find the required hash, they notify the parent. Else, they notify the parent that the given characterCount didn't satisfy the requirements, and start working for the next characterCount. The parent maintains and allocates the status of the character counts to be tried.
3) Client.fsx: This file connects with the server and gets a character count as an input from the server. The client generates (processorCount - 1) actors. Next, it divides (62 ^ characterCount) by the number of actors to get the quotient. Each actor loops from 0 to quotient to generate that many number of hashes and compares them with the leading number of zeros. If any one of the actors is successful, it notifies the parent of the client which in turn notifies the server and the server prints the hash. If none of the actors are successful, they notify the parent of the client which in turn notifies the server and gets the next character count as the input.

### Machine Details

We tested our code on three machines.

Server: 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz with 4 cores.

Client 1: AMD Ryzen Threadripper 1920X 12-Core Processor.

Client 2: Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz with 4 cores.

### 1.  Work Unit
1) Server: The work unit for every individual actor in the server is (62 ^ characterCount). We did this in order to ensure multiple permutations of of each character count.
2) Client: The work unit for every individual actor in the client is (62 ^ characterCount) % numberOfActors. We did this to ensure that all the threads on the machine are being utilized and reduction in the number of message passing between parent and miners.

### 2. Result of running program for Leading zeros = 4
The screenshot for the server is attached below. 
![](https://github.com/shlokgilda/cop_5615/blob/main/project1/outputScreenShots/leadingZerosServer4.png)

CPU utilization: 133%

CPU time / Real time: 8.14/6.56 = 1.24

Before we could connect the clients, the server finished processing. Hence, we have included multiple cases of different leading zeros and calculated the ratio of cpu time to real time for each of them.

### 3. CPU Time to Real for different values of leading zeros:

#### Leading zeros = 7

The screenshot for the server is attached below.
![](https://github.com/shlokgilda/cop_5615/blob/main/project1/outputScreenShots/leadingZerosServer7.png)

CPU utilization: 563%

CPU time / Real time: 367.07/65.83 = 5.57

The screenshot for the client 1 is attached below.
![](https://github.com/shlokgilda/cop_5615/blob/main/project1/outputScreenShots/leadingZerosClientOne.png)

CPU utilization: 284%

CPU time / Real time: 149.79/54.70 = 2.73

The screenshot for the client 2 is attached below.
![](https://github.com/shlokgilda/cop_5615/blob/main/project1/outputScreenShots/leadingZerosClientTwo.png)

CPU utilization: 565%

CPU time / Real time: 343.06/61.44 = 5.58 

#### Max leading zeros = 8

We were able to run our code with max leading zeros value = 8. The screenshot for the server is attached below. 
![](https://github.com/shlokgilda/cop_5615/blob/main/project1/outputScreenShots/leadingZerosServer8.png)

CPU utilization: 531%

CPU time / Real time: 201.33/38.25 = 5.26

We used only one client machine (client 1) while computing this. Unfortunately, we couldn't capture screenshots from client machines.

### 4. The coin with the most 0s we managed to find is for 8 leading zeros:

String: shlok;p508Xv2Yfe  
Hash: 000000008D949FD46813EB288952FE8BC123124ED83878FCB60BE359D8DD0E98
        
We have checked the answer for correctness on https://xorbin.com/tools/sha256-hash-calculator
![](https://github.com/shlokgilda/cop_5615/blob/main/project1/outputScreenShots/xorbinAnswer.png)

### 5. Max connected working machines

We were able to connect three machines: 1 server and 2 clients. We believe we can easily connect more machines, however, due to lack of availability of machines, we could't connect multiple machines. 
# bitcoin_mining
